{
  "version": 3,
  "sources": ["../src/utils/hi-res-timestamp.ts", "../src/lib/stat.ts", "../src/lib/stats.ts"],
  "sourcesContent": ["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default function getHiResTimestamp(): number {\n  let timestamp;\n  // Get best timer available.\n  if (typeof window !== 'undefined' && window.performance) {\n    timestamp = window.performance.now();\n  } else if (typeof process !== 'undefined' && process.hrtime) {\n    const timeParts = process.hrtime();\n    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;\n  } else {\n    timestamp = Date.now();\n  }\n\n  return timestamp;\n}\n", "import getHiResTimestamp from '../utils/hi-res-timestamp';\n\nexport default class Stat {\n  readonly name: string;\n  readonly type: string | undefined;\n  sampleSize: number = 1;\n  time: number = 0;\n  count: number = 0;\n  samples: number = 0;\n  lastTiming: number = 0;\n  lastSampleTime: number = 0;\n  lastSampleCount: number = 0;\n\n  _count: number = 0;\n  _time: number = 0;\n  _samples: number = 0;\n  _startTime: number = 0;\n  _timerPending: boolean = false;\n\n  constructor(name: string, type?: string) {\n    this.name = name;\n    this.type = type;\n    this.reset();\n  }\n\n  reset(): this {\n    this.time = 0;\n    this.count = 0;\n    this.samples = 0;\n    this.lastTiming = 0;\n    this.lastSampleTime = 0;\n    this.lastSampleCount = 0;\n    this._count = 0;\n    this._time = 0;\n    this._samples = 0;\n    this._startTime = 0;\n    this._timerPending = false;\n\n    return this;\n  }\n\n  setSampleSize(samples: number): this {\n    this.sampleSize = samples;\n    return this;\n  }\n\n  /** Call to increment count (+1) */\n  incrementCount(): this {\n    this.addCount(1);\n\n    return this;\n  }\n\n  /** Call to decrement count (-1) */\n  decrementCount(): this {\n    this.subtractCount(1);\n\n    return this;\n  }\n\n  /** Increase count */\n  addCount(value: number): this {\n    this._count += value;\n    this._samples++;\n    this._checkSampling();\n\n    return this;\n  }\n\n  /** Decrease count */\n  subtractCount(value: number): this {\n    this._count -= value;\n    this._samples++;\n    this._checkSampling();\n\n    return this;\n  }\n\n  /** Add an arbitrary timing and bump the count */\n  addTime(time: number): this {\n    this._time += time;\n    this.lastTiming = time;\n    this._samples++;\n    this._checkSampling();\n\n    return this;\n  }\n\n  /** Start a timer */\n  timeStart(): this {\n    this._startTime = getHiResTimestamp();\n    this._timerPending = true;\n\n    return this;\n  }\n\n  /** End a timer. Adds to time and bumps the timing count. */\n  timeEnd(): this {\n    if (!this._timerPending) {\n      return this;\n    }\n    this.addTime(getHiResTimestamp() - this._startTime);\n    this._timerPending = false;\n    this._checkSampling();\n\n    return this;\n  }\n\n  getSampleAverageCount(): number {\n    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;\n  }\n\n  /** Calculate average time / count for the previous window */\n  getSampleAverageTime(): number {\n    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;\n  }\n\n  /** Calculate counts per second for the previous window */\n  getSampleHz(): number {\n    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;\n  }\n\n  getAverageCount(): number {\n    return this.samples > 0 ? this.count / this.samples : 0;\n  }\n\n  /** Calculate average time / count */\n  getAverageTime(): number {\n    return this.samples > 0 ? this.time / this.samples : 0;\n  }\n\n  /** Calculate counts per second */\n  getHz(): number {\n    return this.time > 0 ? this.samples / (this.time / 1000) : 0;\n  }\n\n  _checkSampling(): void {\n    if (this._samples === this.sampleSize) {\n      this.lastSampleTime = this._time;\n      this.lastSampleCount = this._count;\n      this.count += this._count;\n      this.time += this._time;\n      this.samples += this._samples;\n      this._time = 0;\n      this._count = 0;\n      this._samples = 0;\n    }\n  }\n}\n", "// probe.gl, MIT license\n\nimport Stat from './stat';\n\ntype TableEntry = {\n  time: number;\n  count: number;\n  average: number;\n  hz: number;\n};\n\n/** A \"bag\" of `Stat` objects, can be visualized using `StatsWidget` */\nexport default class Stats {\n  readonly id: string;\n  readonly stats: Record<string, Stat> = {};\n\n  constructor(options: {id: string; stats?: Stats | Stat[] | {name: string; type?: string}[]}) {\n    this.id = options.id;\n    this.stats = {};\n\n    this._initializeStats(options.stats);\n\n    Object.seal(this);\n  }\n\n  /** Acquire a stat. Create if it doesn't exist. */\n  get(name: string, type: string = 'count'): Stat {\n    return this._getOrCreate({name, type});\n  }\n\n  get size(): number {\n    return Object.keys(this.stats).length;\n  }\n\n  /** Reset all stats */\n  reset(): this {\n    for (const stat of Object.values(this.stats)) {\n      stat.reset();\n    }\n\n    return this;\n  }\n\n  forEach(fn: (stat: Stat) => void): void {\n    for (const stat of Object.values(this.stats)) {\n      fn(stat);\n    }\n  }\n\n  getTable(): Record<string, TableEntry> {\n    const table: Record<string, TableEntry> = {};\n    this.forEach(stat => {\n      table[stat.name] = {\n        time: stat.time || 0,\n        count: stat.count || 0,\n        average: stat.getAverageTime() || 0,\n        hz: stat.getHz() || 0\n      };\n    });\n\n    return table;\n  }\n\n  _initializeStats(stats: Stats | Stat[] | {name: string; type?: string}[] = []): void {\n    stats.forEach(stat => this._getOrCreate(stat));\n  }\n\n  _getOrCreate(stat: Stat | {name: string, type?: string}): Stat {\n    const {name, type} = stat;\n    let result = this.stats[name];\n    if (!result) {\n      if (stat instanceof Stat) {\n        result = stat;\n      } else {\n        result = new Stat(name, type);\n      }\n      this.stats[name] = result;\n    }\n    return result;\n  }\n}\n"],
  "mappings": "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",
  "names": ["timestamp", "window", "performance", "now", "process", "hrtime", "timeParts", "Date", "Stat", "constructor", "name", "type", "sampleSize", "time", "count", "samples", "lastTiming", "lastSampleTime", "lastSampleCount", "_count", "_time", "_samples", "_startTime", "_timerPending", "reset", "setSampleSize", "incrementCount", "addCount", "decrementCount", "subtractCount", "value", "_checkSampling", "addTime", "timeStart", "getHiResTimestamp", "timeEnd", "getSampleAverageCount", "getSampleAverageTime", "getSampleHz", "getAverageCount", "getAverageTime", "getHz", "Stats", "constructor", "options", "id", "stats", "_initializeStats", "Object", "seal", "get", "name", "type", "_getOrCreate", "size", "keys", "length", "reset", "stat", "values", "forEach", "fn", "getTable", "table", "time", "count", "average", "getAverageTime", "hz", "getHz", "result", "Stat"]
}
